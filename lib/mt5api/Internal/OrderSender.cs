using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading.Tasks;

namespace mtapi.mt5
{
    class OrderSender
    {
        Connection Connection;
        internal OrderSender(Connection connection)
        {
            Connection = connection;
        }

        public void Send(TradeRequest req)
        {
            OutBuf buf = new OutBuf();
            buf.Add((byte)0);
            WriteRequest(buf, req, 96, Connection.TradeBuild);
            if (Connection.TradeBuild <= 1891)
            {
                req.Volume /= 10000;
                req.s174 /= 10000;
            }
            ProtectTradeRequest(req, buf);
            Connection.SendCompress(0x6C, buf).Wait();
        }

        public static void check(byte[] src)
        {
            try
            {
                var lines = File.ReadAllLines("C:\\YandexDisk\\Tim\\java\\mt5api\\ar.txt");
                int ind = 0;
                foreach (var line in lines)
                {
                    if (!line.Trim().StartsWith("["))
                        continue;
                    ind = Convert.ToInt32(line.Substring(line.IndexOf("[") + 1, line.IndexOf("]") - line.IndexOf("[") -1), 16);
                    byte val = hexToByte(line.Substring(line.IndexOf("0x", 5) + 2, line.IndexOf("'") - line.IndexOf("0x", 5) -3));
                    if (ind > src.Length - 1)
                        throw new Exception(ind + " big " + (src.Length - 1));
                    if (src[ind] != val)
                        throw new Exception(ind + " " + src[ind] + " not " + val);
                }
                if (ind != src.Length - 1)
                    throw new Exception(ind + "!=" + (src.Length - 1));
            }
            catch (IOException e)
            {
                throw e;
            }
        }

        public static byte hexToByte(String hexString)
        {
            return Convert.ToByte(hexString, 16);
        }

        void equal(byte[] ar1, byte[] ar2)
        {
            if (ar1.Length != ar2.Length)
                throw new Exception("len not equal");
            for (int i = 0; i < ar1.Length; i++)
            {
                if (ar1[i] != ar2[i])
                    throw new Exception("not equal " + i);
            }
        }

        private void ProtectTradeRequest(TradeRequest req, OutBuf buf)
        {
            if (Connection.TradeBuild > 1349)
                CryptRequestProtectKey(req, buf);
            else
                CryptRequestAccountLogon(req, buf);
        }

        private void CryptRequestProtectKey(TradeRequest req, OutBuf buf)
        {
            if (Connection.ProtectKey == null)
                if ((Connection.QC.Account.TradeFlags & 8) != 0 || Connection.QC.PfxFile == null)
                    throw new InvestorModeException("Investor mode");
                else
                {
                    X509Certificate2Collection collection = new X509Certificate2Collection();
                    collection.Import(Connection.QC.PfxFile, Connection.QC.PfxFilePassword, X509KeyStorageFlags.Exportable);
                    byte[] sign = null;
                    X509Certificate2 certif = null;
                    foreach (X509Certificate2 item in collection)
                        if(item.GetRSAPrivateKey() != null)
                            certif = item;
                    if (certif == null)
                        throw new ConnectionException("RSA private key not found");
                    using (RSA rsa = certif.GetRSAPrivateKey())
                        if (rsa != null)
                            sign = rsa.SignData(UDT.GetBytes(req), HashAlgorithmName.SHA1, RSASignaturePadding.Pkcs1);
                    Array.Reverse(sign, 0, sign.Length);
                    buf.ByteToBuffer(0x2C);
                    buf.LongToBuffer((uint)sign.Length);
                    buf.DataToBuffer(sign);
                    return;
                }
            //byte[] key = { 0xd1, 0x68, 0x5a, 0x59, 0xde, 0x51, 0xf9, 0xdd, 0x65, 0x83, 0xd7, 0x1b, 0x89, 0x18, 0xbe, 0xa9, 0x4c, 0x0a, 0x6b, 0x7d, 0xfb, 0x66, 0xab, 0x8a, 0x53, 0x0a, 0xeb, 0x7e, 0x6b, 0x68, 0x31, 0x50 };
            //key = Crypt.EasyDecrypt(QuoteClient.Connection.ProtectKey); //TODO QuoteClient.Connection.ProtectKey
            var key = Connection.ProtectKey;
            //key = Crypt.EasyDecrypt(key);
            Array.Resize(ref key, 32);
            var mod1 = new byte[64];
            key.CopyTo(mod1, 0);
            var mod2 = new byte[64];
            key.CopyTo(mod2, 0);
            for (int i = 0; i < 64; i++)
            {
                mod1[i] ^= 0x36;
                mod2[i] ^= 0x5C;
            }
            var data = UDT.GetBytes(req);
            //for (int i = 302; i <= 351; i++)
            //    data[i] = 0xfe;
            //var d = new byte[] { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3b, 0x94, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x00, 0x55, 0x00, 0x52, 0x00, 0x55, 0x00, 0x53, 0x00, 0x44, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x40, 0x42, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            //equal(d, data);
            var hash1 = new byte[32];
            Sha256 sha = new Sha256();
            sha.AddData(mod1, 0, (uint)mod1.Length);
            sha.AddData(data, 0, (uint)data.Length);
            sha.GetHash().CopyTo(hash1, 0);
            sha = new Sha256();
            sha.AddData(mod2, 0, (uint)mod2.Length);
            sha.AddData(hash1, 0, (uint)hash1.Length);
            byte[] hash2 = new byte[32];
            sha.GetHash().CopyTo(hash2, 0);
            buf.Add((byte)0x55);
            buf.Add((int)32);
            buf.Add(hash2);
        }


        private void CryptRequestAccountLogon(TradeRequest req, OutBuf buf)
        {
            throw new NotImplementedException();
        }


        void WriteRequest(OutBuf buf, TradeRequest req, int mode, int tradeBuild)
        {
            switch (mode)
            {
                case 0:
                case 4:
                case 5:
                case 7:
                case 8:
                case 9:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 66:
                case 67:
                case 69:
                case 73:
                case 96:
                case 97:
                case 98:
                case 99:
                case 100:
                case 101:
                    if (tradeBuild > 1891)
                        break;
                    //buf.Add(UDT.GetBytes(req, 0x160));
                    //ulong value = req.Lots / 10000;
                    //buf.Add(value);
                    //buf.Add(req.s168);
                    //buf.Add(req.Digits);
                    //long v= req.s174 / 10000;
                    //buf.Add(value);
                    throw new NotImplementedException();
                    //return bufMan.DataToBuffer(s17C, 0x1A4);
            }
            buf.Add(UDT.GetBytes(req));
        }

    }
}
